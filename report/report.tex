\documentclass[a4paper, oneside, notitlepage]{article}

\usepackage[english]{babel}
\usepackage{fullpage}
\usepackage{fixltx2e}
\usepackage{xspace}
\usepackage{relsize}


% font stuff
\usepackage[T1]{fontenc}
\usepackage{microtype}
\usepackage{lmodern} \normalfont
% lmodern has no smallcaps bold , so we replace it by computer-modern (closely
% related)
\DeclareFontShape{T1}{lmr}{bx}{sc} { <-> ssub * cmr/bx/sc }{}
\usepackage[scaled=0.8]{beramono} % monospace font with bold support


% nicely formatted acronyms 
%\newcommand{\Rascal}{\textsc{Rascal}\xspace}
\newcommand{\CSF}{\textsmaller{CSF}\xspace}
\newcommand{\ASFSDF}{\textsmaller{ASF\hspace{-.05em}\raisebox{.4ex}{\tiny\bf +}SDF}\xspace}
\newcommand{\SDF}{\textsmaller{SDF}\xspace}
\newcommand{\ASF}{\textsmaller{ASF}\xspace}
\newcommand{\AST}{\textsmaller{AST}\xspace}
\newcommand{\CST}{\textsmaller{CST}\xspace}
\newcommand{\IDE}{\textsmaller{IDE}\xspace}
\newcommand{\LOC}{\textsmaller{LOC}\xspace}
\newcommand{\ADT}{\textsmaller{ADT}\xspace}
\newcommand{\ADTs}{\textsmaller{ADTs}\xspace}
\newcommand{\MSOS}{\textsmaller{MSOS}\xspace}

\newcommand{\filename}[1]{\texttt{#1}\xspace}
\newcommand{\code}[1]{\texttt{#1}\xspace}
\usepackage{highlight}
\usepackage{rascal}
\usepackage{listings}

\lstset{% general command to set parameter(s) 
	basicstyle=\ttfamily\small,%
	xleftmargin=.25in,%
    xrightmargin=.25in%
}

\lstdefinelanguage{CSF}%
{%
	keywords={Glossary, Alias },% 
	moredelim=[s][\itshape]{\$}{\$},%
	lineskip={-5pt}%
}

% todo marker
\usepackage[svgnames]{xcolor}
\usepackage{marginfix}
\newcommand{\todo}[1]{%
	\marginpar{%
	\colorbox{yellow}{\parbox{0.9\marginparwidth}{%
		\raggedright \footnotesize #1}}}}

\title{Funcons in Rascal - report}
\author{Davy Landman}
\begin{document}
\maketitle

\todo{Make sure to chose between sort/non-terminal}

\section*{Introduction}
This document will describe the translation from funcons implemented in \ASFSDF
to the implementation in \Rascal.
The first section will summerize the overall architecture, the second section
will describe the manual translation to rascal, the third a generative approach
and the last two sections will discuss the differences between the two
implementations.


\section{The architecture}
	\subsection{\ASFSDF}
		In \ASFSDF the funcons are implemented in a two stage approach.
		The first stage is `compiling' the \CSF~(funcons specifications) into
		\SDF definitions.
		These definitions can then be used to describe the semantics of a
		programming language.
		These funcon semantics are connected to syntax of the programming
		language using the \ASF equations.

		\paragraph{Current limitations:}
			At the time of writing, not all funcons are specified in \CSF,
			which means that not all the \SDF defined funcons were generated
			from the \CSF specifications. 
			Moreover, the \CSF specifications contain the descriptions of how to
			`interpret' a funcon, but the generation of an interpreter was not yet
			implemented. 
			\todo{mention MSOS etc?}
		

	\subsection{\Rascal}
		The \Rascal funcons implementation aims to closely match the \ASFSDF
		implementation.
		\Rascal however, has more features suited for this domain and we have
		chosen to use those features to showcase the possible improvements.

		The first stage is similiar, \Rascal also uses \CSF to generate the
		funcon specifications.
		However, since \Rascal features functions and \ADTs we do not generate 
		funcon as a language specification but we generate \Rascal files containing
		the funcon \ADT structure.
		These funcon \ADTs can then be used to define the semantics of a
		programming language in a similar fashion as in \ASFSDF.
		In our example we chose to define the funcons for the \AST of a
		language, but this is no limitation of \Rascal and we could also defined
		funcons for the \CST of a language.

		\paragraph{Current limitations:}
			Same as in \ASFSDF.


\section{Manual implementation}
	Since only a subset of the funcons were defined in the \CSF specifications
	we first created a manual translation of the funcons in \SDF.
	While this translation lacks modularity, it does provide an insight of how
	a \Rascal funcons implementation works.

	\subsection{The funcons \ADT}
		The \filename{src/funcons/funcons.rsc} file contains the complete funcons
		\ADT equivelant to the \SDF implementation\footnote{Since the minus
		character is not allowed in \Rascal names, we used camel casing.}.
		Below is a snippet from this file.

\begin{rascal}
data Expr 
	= \data(Data dt)
	| abs(Patt pattern, Comm command)
	| application(Op op, list[Expr] exprs)
	| assignVar(Expr var, Expr val)
	| bound(Id id)
	| deref(Expr var)
	| derefIfVar(Expr var)
	| env(Decl decl)
	| newVar(Expr typeExpr)
	| newVar(Type \type)
	| op(list[Expr] expressions)
	| tup(list[Expr] tuples)
	| tupSeq(list[Expr] tuples)
	| typed(Expr expr, Type check)
	;
\end{rascal}
		
		\subsubsection{\code{Op} funcon}
		The \code{Op} funcon causes the biggest difference in implementation, since
		the \SDF definition creates a structure not easily represented in the \ADT
		structure of \Rascal (this funcon is an example of a funcon only defined
		in \SDF).

		Take for example the funcon \code{int-plus} which can be used used as 
		\code{int-plus(	Expr[[EXP1]], Expr[[EXP1]])}, 
		but also as 
		\code{comp(int-plus, int-neq)}.

		We could solve this by adding the \code{int-plus} (and all the others)
		to the \code{Data} and \code{Expr} sorts and the \code{Op} sort, but this would
		polute our \ADT definition.
		So we chose to only add \code{int-plus} to the \code{Op} sort and add a
		\code{application} alternative to the \code{Data} and \code{Expr} sorts.
		This would mean we would have to write the first example as:
		\irascal{application(intPlus(), [Expr(EXP1), Expr(EXP2)])}.

		However, \Rascal has rewrite rules, and this allows us to write 
		\irascal{intPlus(Expr(EXP1), Expr(EXP2))}.
		It is important to note that we asume to know the amount of parameter
		usually used for the funcon, else we would have to wrap the parameters
		into a list.

		\subsubsection{Explicit production chains}
		In the \ASFSDF implementation, production chains are often used.
		This is not visible for the funcons users since \ASFSDF allows implicit
		chaining when they cause no ambiguity.
		\Rascal does not support implicit chaining, and this makes a funcon such
		as \code{Expr[[ NatCon ]] = NatCon} in \ASF becomes
		\code{\ldots = data(int(nat(Nat::natCon(val))))} in \Rascal.
		We can solve this with a rewrite rule, but it means that for each funcon
		we have to determine where it is actually used and create a rewrite rule
		for that usage.
	
	\subsection{Semantic description using funcons}

		The \filename{src/lang/pico/semantic/Main.rsc} file contains the semantic
		description of the pico language, similar to the semantic description of
		the pico language in \ASFSDF.
		Below are two definitions, the first is for the loop command, and the
		second is for the add expression.

\begin{rascal}
public Comm pico2Comm(Statement::loop(con, body)) =
	whileLoop( 
		noteq(pico2Expr(con), natCon(0)), 
		pico2Comm(body)
	);

public Expr pico2Expr(add(lhs, rhs)) = intPlus(pico2Expr(lhs), pico2Expr(rhs));
\end{rascal}

		\subsubsection{Naming collisions}
		In the example we see that the Patterns (pattern based invocation) use
		the qualified name for a alternative, this is due to naming collisions
		with the funcon names.
		The \AST contains the \code{loop} alternative for the \code{Statement}
		sort, but the \code{Comm} funcon also defines the \code{loop} funcon.
		In most places \Rascal correctly handles these collisions, but at the
		moment the patterns require fully qualified names to avoid collisions.

		\subsubsection{List deconstruction}
		\todo{how is this called again?}
		The only real elegance difference between the \Rascal semantic
		description and the \ASFSDF description is caused by a current
		limitation of rascal pattern matching to not allow to match an empty
		list.
		The following snippet demonstrates the required code needed to
		destruct a list:

\begin{rascal}
public Comm pico2Comm(list[Statement] statements) =
	(statements == [] ) ? skip() : seq([ pico2Comm(s) | s <- statements]);
\end{rascal}

		In a future version of \Rascal we would prefer to have support for the
		empty list/set/map in the patterns for function parameters\footnote{Regular
		patterns already support this}.
		Instead of a head/tail deconstruction of the list we use a comprehension
		to map the \AST to the correct funcons.

		\subsubsection{\AST instead of \CST}
		For our implementation we chose to write the semantic definition against
		the \AST of the pico language, instead of the \CST as the \ASFSDF
		solution does.
		However, this is not due to a limitation of \Rascal, below is a snippet
		of how the \code{pico2Expr(add(lhs, rhs))} would look if written for the
		\CST.

\begin{rascal}
public Expr pico2Expr(`<Expression lhs> + <Expression rhs>`) 
	= intPlus(pico2Expr(lhs), pico2Expr(rhs));
\end{rascal}

\section{CSF generated implementation}
	Since we have demonstrated that all the funcon concepts from \ASFSDF can be
	translated to \Rascal, we explain in this section how we could use \Rascal
	to generate the funcons based on the \CSF specifications.

	\subsection{\CSF}
	The \CSF file defines the funcon, it describes it in natural language and it
	formalizes its semantics using \MSOS.
	Below is the definition of the \code{decl} funcon.
	We see that the funcon is part of the \code{Decl} funcons and takes a
	\code{Comm} as parameter.
	
\begin{lstlisting}[language=CSF]
Decl ::= decl(Comm)

Glossary:

This allows $Comm$ to be executed in a sequence of declarations,
computing the empty environment.

Alias:  declaration

1:      Comm --> Comm'
        ---
        decl(Comm) --> decl(Comm')

2:      decl(skip) --> map-empty

3:      Comm ==> Comm'
        ---
        decl(Comm) ==> decl(Comm') : map-empty

\end{lstlisting}

	We rewrote the \SDF grammar definition to a \Rascal grammar definition, this
	grammar is located in the
	\filename{src/csf2rascal/lang/csf/cst/MainCSFGrammar.rsc} file.
	The only real difference is that we marked the words such as ``Glossary'' as
	keywords, this is important for disambiguation and provides the \IDE with
	information for simple highlighting.

	Since \Rascal provides the \code{implode} function which automatically maps
	a \CST onto a \AST, we defined the \AST for \CSF and used that \AST to
	write our generator.
	The \AST is defined in the \filename{src/csf2rascal/lang/csf/ast/Main.rsc} file.

	\subsection{\Rascal funcons generation}
	Similar to the \ASFSDF approach (\filename{CSF-to-SDF.asf}) we generate
	\Rascal files from within \Rascal.
	The \filename{src/csf2rascal/lang/csf/generation/Generate.rsc} file
	implements this generation in 249 \LOC (blank lines excluded).

	Unlike the manual implementation, the generated funcons have the same
	modularity as the \ASFSDF implementation.
	A user of the funcon can import just the needed funcons.
	We have added a few small features in comparison to the \ASFSDF generation.
	We added support for the aliased funcons, and we used \Rascal's
	\code{@doc\{\}} source code annotations to add the informal description of a
	funcon.

	Below is the \Rascal implementation of the above \CSF file.

\begin{rascal}
extend csf2rascal::generated::Decl::Decl;
import csf2rascal::generated::Comm::Comm;
 
@doc{This allows Comm to be executed in a sequence of declarations, computing the
 empty environment.}
data Decl = decl(Comm comm);

public Decl declaration(Comm comm) = 
	decl(comm);
\end{rascal}

\section{Limitations of rascal implementation}

\section{Advantages of rascal implementaton}

\end{document}
