\RequirePackage[l2tabu,orthodox]{nag}
\documentclass[a4paper, oneside, notitlepage]{article}

\usepackage[english]{babel}
\usepackage{fullpage}
\usepackage{fixltx2e}
\usepackage{xspace}
\usepackage{relsize}
\usepackage{listings}
\lstset{language=Java, basicstyle=\small}


% font stuff
\usepackage[T1]{fontenc}
\usepackage{microtype}
\usepackage{lmodern} \normalfont
% lmodern has no smallcaps bold , so we replace it by computer-modern (closely
% related)
\DeclareFontShape{T1}{lmr}{bx}{sc} { <-> ssub * cmr/bx/sc }{}

\title{Funcons in Rascal - report}
\author{Davy Landman}

% nicely formatted acronyms 
\newcommand{\Rascal}{\textsc{Rascal}\xspace}
\newcommand{\CSF}{\textsmaller{CSF}\xspace}
\newcommand{\ASFSDF}{\textsmaller{ASF-SDF}\xspace}
\newcommand{\SDF}{\textsmaller{SDF}\xspace}
\newcommand{\ASF}{\textsmaller{ASF}\xspace}
\newcommand{\AST}{\textsmaller{AST}\xspace}
\newcommand{\CST}{\textsmaller{CST}\xspace}
\newcommand{\ADT}{\textsmaller{ADT}\xspace}
\newcommand{\ADTs}{\textsmaller{ADTs}\xspace}

\newcommand{\filename}[1]{\texttt{#1}\xspace}
\newcommand{\code}[1]{\texttt{#1}\xspace}

% todo marker
\usepackage[svgnames]{xcolor}
\usepackage{marginfix}
\newcommand{\todo}[1]{%
	\marginpar{%
	\colorbox{yellow}{\parbox{0.9\marginparwidth}{%
		\raggedright \footnotesize #1}}}}
	
\begin{document}
\maketitle

\section*{Introduction}
This document will describe the translation from funcons implemented in \ASFSDF
to the implementation in \Rascal.
The first section will summerize the overall architecture, the second section
will describe the manual translation to rascal, the third a generative approach
and the last two sections will discuss the differences between the two
implementations.


\section{The architecture}
	\subsection{\ASFSDF}
		In \ASFSDF the funcons are implemented in a two stage approach.
		The first stage is `compiling' the \CSF~(funcons specifications) into
		\SDF definitions.
		These definitions can then be used to describe the semantics of a
		programming language.
		These funcon semantics are connected to syntax of the programming
		language using the \ASF equations.

		\paragraph{Current limitations:}
			At the time of writing, not all funcons are specified in \CSF,
			which means that not all the \SDF defined funcons were generated
			from the \CSF specifications. 
			Moreover, the \CSF specifications contain the descriptions of how to
			`interpret' a funcon, but the generation of an interpreter was not yet
			implemented. 
			\todo{mention MSOS etc?}
		

	\subsection{\Rascal}
		The \Rascal funcons implementation aims to closely match the \ASFSDF
		implementation.
		\Rascal however, has more features suited for this domain and we have
		chosen to use those features to showcase the possible improvements.

		The first stage is similiar, \Rascal also uses \CSF to generate the
		funcon specifications.
		However, since \Rascal features functions and \ADTs we do not generate 
		funcon as a language specification but we generate \Rascal files containing
		the funcon \ADT structure.
		These funcon \ADTs can then be used to define the semantics of a
		programming language in a similar fashion as in \ASFSDF.
		In our example we chose to define the funcons for the \AST of a
		language, but this is no limitation of \Rascal and we could also defined
		funcons for the \CST of a language.

		\paragraph{Current limitations:}
			Same as in \ASFSDF.


\section{Manual implementation}
	Since only a subset of the funcons were defined in the \CSF specifications
	we first created a manual translation of the funcons in \SDF.
	While this translation lacks modularity, it does provide an insight of how
	a \Rascal funcons implementation works.

	\subsection{The funcons \ADT}
		The \filename{src/funcons/funcons.rsc} file contains the complete funcons
		\ADT equivelant to the \SDF implementation.

		\subsubsection{\code{Op} funcon}
		The \code{Op} funcon causes the biggest difference in implementation, since
		the \SDF definition creates a structure not easily represented in the \ADT
		structure of \Rascal (this funcon is an example of a funcon only defined
		in \SDF).

		Take for example the funcon \code{int-plus} which can be used used as 
		\code{int-plus(	Expr[[EXP1]], Expr[[EXP1]])}, 
		but also as 
		\code{comp(int-plus, int-neq)}.

		We could solve this by adding the \code{int-plus} (and all the others)
		to the \code{Data} sort and the \code{Op} sort, but this would
		polute our \ADT definition.
		So we chose to only add \code{int-plus} to the \code{Op} sort and add a
		\code{application} alternative to the \code{Data} sort.
		This would mean we would have to write the first example as:
		\code{application(intPlus(), [Expr(EXP1), Expr(EXP2)])}.

		However, \Rascal has rewrite rules, and this allows us to write 
		\code{intPlus(Expr(EXP1), Expr(EXP2))}.
		It is important to note that we asume to know the amount of parameter
		usually used for the funcon, else we would have to wrap the parameters
		into a list.

		\subsubsection{Explicit production chains}
		In the \ASFSDF implementation, production chains are often used.
		This is not visible for the funcons users since \ASFSDF allows implicit
		chaining when they cause no ambiguity.
		\Rascal does not support implicit chaining, and this makes a funcon such
		as \code{Expr[[ NatCon ]] = NatCon} in \ASF become 
		\code{\ldots = data(int(nat(Nat::natCon(val))))} in \Rascal.
		We can solve this with a rewrite rule, but it means that for each funcon
		we have to determine where it is actually used and create a rewrite rule
		for that usage.
	
	\subsection{Semantic description using funcons}
	

	\begin{lstlisting}
public Comm pico2Comm(Statement::loop(con, body)) =
	whileLoop( 
		noteq(pico2Expr(con), natCon(0)), 
		pico2Comm(body)
	);
	\end{lstlisting}


\section{CSF generated implementation}

\section{Limitations of rascal implementation}

\section{Advantages of rascal implementaton}

\end{document}
